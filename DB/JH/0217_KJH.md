
##  0217

1. Binary tree : 마지막 레벨을 제외한 모든 레벨에 노드가 가득 차있다. 
2. parent node : (I-2)/2; left node : (I * 2 + 1). right node : (I * 2 + 2)
3. 우선순위 큐 : 힙으로 구현하자. 
4. max heap : 부모노드의 키가 자식노드의 키와 크거나 같다. 
5. min heap : 부모노드의 키가 자식노드의 키와 작거나 같다. 
6. 힙의 표준 자료구조는 배열이다. 
7. 힙의 균형이 깨지면 heapify 를 해준다. 
8. 힙의 삽입. 새로운 노드를 마지막 노드에 삽입한다. 그리고 새로운 노드를 부모 노드와 교환한다. 
9. 힙의 삭제. 루트 노드를 삭제하고 마지막 노드를 루트에 넣는다. 그 후 재구성 한다 
10. 버블 소트. 배열의 두 수를 선택 후 정렬한다. 
11. 선택 정렬. 주어진 리스트에서 최소의 값을 찾고 맨 앞과 바꾼다. 그 후 나머지 리스트도 교체해준다 
12. 삽입 정렬. 자신의 위치를 찾아서 삽입한다. 
13. 병합 정렬. 분할 정복을 이용한다. 리스트를 분할하고 정렬하고 합친다. 
14. 퀵 소트. 피봇을 고르고. 피봇보다 작은것은 피봇 앞에 큰 것은 피봇 뒤에 둔다. 
15. 해쉬. 데이터를 고정된 크기의 값으로 바꾸는 것이다. 

🖍특징. 입력값이 조금만 변해도 출력값이 달라진다. 출력값을 통해 입력값의 유추가 어렵다. 동일한 입력값을 주면 동일한 출력값이 반환된다. 

1. 해쉬 맵. key-value 의 구조이다. 키가 중복되지 않는다. value 는 중복을 허용한다. null 허용한다. 순서를 보장한다. → 많은 양의 데이터를 빠르게 탐색이 가능하다 
2. 해쉬 셋. 순서를 보장하지 않으며 중복을 허용하지 않고 널값을 허용한다. 
3. HashTable 에서 Collision 해결 방법. 
- open addressing. 충돌이 발생하면 해쉬 테이블에서 새로운 슬롯을 찾는다. 추가적인 메모리를 사용하지 않는다. (선형 조사법: 충돌이 발생하면 해쉬에 일정값. 이차 조사법 : 제곱수로 건너뛴다.)

단점 : 글러스팅 현상이 발생한다. (특정 구간에 몰리는 것이며 평균 탐색 시간이 증가한다) 

- separate chaining : linked list 로 충돌을 해결한다. 충돌이 발생하면 연결 리스트에 데이터를 추가한다.

삽입 : 서로 다른 2개의 키. 해쉬값을 저장한다. 시간 복잡도 : O(n)

검사 : 기본 : O(1) 최악 : O(n)

삭제 : O(n) 

16. 이진 탐색 : 중간 값을 정하고. 탐색하고자 하는 값이 중간 값보다 작으면 왼쪽을 탐색하고 중간 값보다 크면 오른쪽을 탐색한다.
## 🙌 0226 (JOIN. STORED PROCEDURE)

### Join

1. Innter Join. 교집합과 유사하다. 하나로 합칠 때 두 테이블에 모두 연관된 값이 있는 유효한 레코드만 가져온다.
   두 테이블 중 어느 한쪽이라도 비어있는 값이나 연관성이 없는 값은 제외된다.
2. Outer Join. 하나로 합칠 때 두 테이블 중 어느 하나라도 값을 가진 레코드가 있으면 도구 출력하는 조인 방법이다.
   Left.Right.
   Full Outer Join : 두개 다. 즉 left join 과 right join 을 합친것이다.
3. 저장 프로시저. 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리문들의 집합이다. 저장 프로시저는 리턴 값이 있을 수도
   없을 수도 있으며 서버에서 실행되기 때문에 속도가 빠르다.
4. 일반 쿼리문은 구문 분석 -> 개체 이름 확인 -> 사용 권한 확인 -> 최적화 -> 컴파일 및 실행 계획 등록 -> 실행
5. 저장 프로시저는 구문 분석 -> 지연된 이름의 확인 -> 생성 권한 확인 -> 시스템 테이블 등록
6. 굳이 저장 프로시저를 써야하나 ?
* SQL Server 의 성능을 향상해준다. why? 여러 개의 쿼리를 한번에 실행할 수 있고 캐시에 있는 것을 사용하기 때문이다.
* 유지보수 및 재활용 측면에서 좋다. why? 개발 언어에 비의존적이며 응용 프로그램에서 직접 SQL 문을 호출하지 않기 때문이다.
* 보안을 강화. 사용자 별로 테이블에 권한을 주지 않고 SP 에만 접근 권한을 준다.
* 네트워크의 부하를 줄일 수 있다. 저장 프로시저를 사용하면 저장 프로시저의 이름, 매개변수 등 몇글자만 전송하면 된다.

단점
* DB 의 확장이 어렵다. DB 의 교체는 거의 불가능하다.
* 데이터 분석이 어렵다. 문제가 생겨도 해당 이슈에 대한 추적이 힘들다.
* 낮은 처리 성능. 문자, 숫자열 연산에서 SP 를 사용하면 오히려 c.java 보다 느린 성능을 보일 수 있다.

예시1. 호출
* CALL 프로시저명(파라미터) 로 함수처럼 사용이 가능하다.
* IN : 프로시저에 값을 전달하며 프로시저 내부에서 값을 수정할 수는 있지만 프로시저가 반환되고 나서 호출자가 수정이 불가능하다.
* OUT : 프로시저의 값을 호출자에게 다시 RETURN 한다.
* INOUT : 호출자에 의해 하나의 변수가 초기화되고 프로시저에 의해 수정된다.

7. 프로시저 목록 확인 : SHOW PROCEDURE STATUS;
8. 프로시저 내용 확인 : SHOW CREATE PROCEDURE 프로시저 이름;
9. 프로시저 삭제 : DROP PROCEDURE 프로시저 이름; 

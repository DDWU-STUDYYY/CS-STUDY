# 20240321

# Greedy Algorithm

- 탐욕 알고리즘이라고도 부르며, 그 순간 최선의 선택을 하는 알고리즘이다. 
- 모든 테스트 케이스를 고려하지 않으며, 현 시점에서 가장 좋아보이는 선택을 한다.
- 결과적으로 최적이라는 보장이 없다. Greedy Algorithm은 대부분 최적해를 보장하지 못한다.
- e.g 이진 트리의 최적합 경로 찾기(모든 노드를 다 보기 전까지 보장 불가능)

## Greedy Algorithm 조건
Greedy Algorithm은 

1. 최적 부분 구조(Optimal Substructure)
 - 큰 문제의 최적의 해가 작은 문제의 최적의 해를 포함한다.
2. 탐욕 선택 속성(Greedy Choice Property)
 - 지금 가장 좋은 선택을 하는 것이 전체 문제의 최선의 선택으로 이어진다는 것을 의미한다. 

이 두가지를 만족해야한다. 

## 예시 : 거스름돈 문제
>동전의 개수가 최소가 되도록 거스름돈을 주자. 

Greedy의 대표적 예시이다. 

다음과 같은 과정을 거친다. 
1. 동전을 내림차순으로 정렬한다.(500원, 50원, 10원)
2. 가장 큰 단위의 동전부터 사용한다.
3. 남은 거스름돈이 0원이 되면 종료.

만약 500원, 100원, 10원있다고 치자. 
거스름돈이 120원이라면, 위 과정으로 (100원 * 1개) + (50원 *2개)로 3개가 최소임을 알 수 있다.

그러나 이 문제의 경우 큰 동전의 단위가 작은 동전의 배수여야 한다(한국 돈 500원, 100원, 50원). 그러므로 센트의 경우 Greedy로 해결할 수 없다. 
-> 이 경우 DP로 프로그래밍으로 최적해를 구할 수 있다.

## Prim Algorithm

Prim Algorithm은 최소 신장트리를 구하는 알고리즘으로, 대표적인 Greedy Algorithm이다.
주어진 그래프를 Min Heap으로 구성하여 문제를 해결할 수 있다. 아래와 같은 방식으로 코드를 짤 수 있다. 

1. 한 노드를 제외한 모든 노드의 Weight를 무한대로 초기화한다. (시작은 어떤 노드를 선택하든 상관없다.)
2. 가중치가 가장 작은 노드를 Heap의 가장 위로 올린다.
3. 가장 위에 존재하는 노드를 뽑으면서 그와 인접한 노드들의 Weight를 갱신하고, Heap에 추가한뒤 Heapify
4. Heap이 빌때까지 2-3을 반복

[관련 백준문제 : 1197](https://www.acmicpc.net/problem/1197)

또 다른 최소 신장트리의 크루스칼 알고리즘 또한 그리디 알고리즘이다. 


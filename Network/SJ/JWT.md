# 20240303

> 참고 : 
> https://jwt.io/introduction

## JWT란?

JWT는 Json Web Token으로, 정보를 JSON 형태로 안전하게 전송하기 위한 방법을 정의하는 개방형 표준(RFC 7519)이다.
HMAC 알고리즘을 사용하여 비밀키 또는 RSA를 이용한 공개키/비밀키 쌍으로 서명할 수 있다. 

 클라이언트와 서버가 정보를 주고 받을때 클라이언트는 헤더에 토큰을 달고 서버에 요청을 하고, 서버는 별도의 인증과정 없이 해당 토큰의 정보를 통해 인증한다. 



## JWT 특징 

### 세션과의 차이점 


우선 http가 stateless(무상태)의 특징을 갖는다는 것을 알아야한다. http는 클라이언트와의 통신이 끝나자마자 그 통신에 대한 정보를 잊어버린다. 만약 로그인한 사용자가 게시판에 돌아다니는 상황이라면 게시판의 다른 버튼을 클릭할 때마다 자신이 로그인한 특정 사용자라는 정보를 서버 측에 주어야한다. 

http의 이러한 특징 때문에 **쿠키와 세션**의 개념이 탄생했다. 

쿠키와 세션의 차이라면 쿠키는 정보를 클라이언트에, 세션은 서버 측에 저장한다는 것이다. 쿠키는 예상할 수 있듯이 보안에 매우 취약하다는 단점이 있기 떄문에 장바구니와 같이 보안과 무관하고 간단한 기능을 구현할 때 사용한다. 

세션의 정보는 서버의 메모리(혹은 데이터베이스)에 저장되어 세션 ID를 통해 식별된다. (Stateful)

세션은 별도의 저장소로 운영되기 때문에 요청이 많아지면 부하가 심해지고, 확장성이 떨어진다는 단점이 있다. 
세션 기반 인증 방식의 이러한 단점 때문에 현재는 토큰 기반 인증 방식인 JWT가 널리 쓰이고 있다.

토큰 자체에 정보가 담겨있기 때문에 서버는 클라이언트 측으로부터 토큰을 받아 사용자 판별만 하면 된다. 
세션과 대조적으로 Stateless의 특징을 가지고 있다. 

### JWT의 구조

>참고 : [이 사이트(JWT 디버거)](https://jwt.io/)에서 값에 따라 Base64URL로 인코딩 되는 것을 확인할 수 있다. <br>

JWT는 아래와 같이 3가지의 구조로 나뉜다. 
1. Header
2. Payload
3. Signature

각 파트는 아래와 같이 .로 구분된다. 
```
xxxx.yyyyy.zzzzz
```

#### 1. Header 
헤더는 일반적으로 토큰 유형(JWT)과 사용되는 서명 알고리즘으로 구성된다.

**예시**
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
#### 2. Payload

토큰의 두 번째 부분은 클레임(Claim)을 포함한다. Payload에 담겨있는 정보 조각을 클레임이라 하는데, 보통 유저에 대한 정보를 담고 있다.

**예시**
```
{
"sub": "1234567890",
"name": "John Doe",
"admin": true
}
```

#### 3. Signature
이 부분을 생성하려면 인코딩된 헤더, 페이로드, 비밀키, 헤더의 암호화 알고리즘으로 서명해야한다. 

예를 들어 HMAC SHA256 알고리즘을 사용하려는 경우 다음과 같이 생성된다.

```
HMACSHA256(
base64UrlEncode(header) + "." +
base64UrlEncode(payload),
secret)
```

Signature은 메시지가 도중에 변조되었는지를 확인하는 용도로 사용된다.
개인키로 서명된 토큰의 경우 JWT의 보낸 사람이 누구인지 확인 가능하다. 

### 동작 과정

1. 사용자가 로그인 또는 회원가입을 한다. 
2. 서버가 요청을 확인하고, secret key를 통해 토큰(Access token, Refresh token)을 발급한다.
3. 해당 JWT 토큰을 클라이언트에 응답값으로 보내준다. 
4. 클라이언트에서는 로그인이 필요한 화면(회원제 게시판, 마이페이지 등)에서 API 요청할때 헤더(Authorization)에 Access token를 달아 보낸다.
5. 서버는 JWT Signature를 체크하고 Payload로부터 사용자 정보를 확인한다.

### Access token, Refresh token

토큰의 경우 보안문제로 만료시간을 갖는다. 
보통 Access token은 1시간, Refresh token은 1~2주 정도(프로젝트마다 다름)이다.
일단 일반적인 요청은 만료기간이 짧은 Access token로 이루어진다. 

유효시간이 지나 Access token이 상했을 경우, 서버는 클라이언트에 401 error Code를 리턴한다.
클라이언트는 Refresh token로 다시 재요청을 하고, 서버는 Refresh token이 유효하다면 새 토큰을 발급해서 클라이언트에 보내준다. 

만약 Refresh token도 만료되었다면(보통 오랫동안 접속을 하지않은 경우) 클라이언트는 재로그인하여 새 토큰을 발급받아야한다.

# 20240313

## JPA란?

JPA는 Java Persistence API의 약자로, 자바 진영의 ORM 기술 표준이다.

여기서 **ORM(Object-Relational Mapping )**이란 관계형 데이터베이스와 객체를 매핑해주는 기술이다. 
개발자가 객체와 관계형 데이터베이스를 각각 설계하면, ORM 프레임워크가 중간에서 이를 매핑해준다.

ORM은 객체지향적인 직관적인 코드로 비즈니스 로직에 집중할 수 있다는 장점이 있고, 이로 인해 생산성을 증가시킬 수 있다는 장점이 있다. 
또한 DBMS에 대한 종속성을 줄일 수 있다.

JPA는 다음과 같은 장점이 있다. 
1. SQL 중심 개발에서 객체 지향적 개발이 가능하다. 
2. 생산성과 유지보수성이 좋아진다. 
3. 상속, 연관관계, 비교와 같은 패러다임의 불일치를 해소해준다.

## Hibernate 란?
JPA의 인터페이스 구현체이다. 내부적으로 JDBC API 사용한다.

# 영속성 컨텍스트 

> 엔티티를 영구히 저장하는 환경

EntityManager를 통해서 접근한다. 
`EntityManager.persist()`

엔티티의 생명주기는 다음과 같다.

1. 비영속 : 단순히 생성되기만 한 상태
2. 영속 : 영속성 컨텍스트에 의해 관리되는 상태 `em.persist(entity);`
3. 준영속 : 영속성 컨텍스트에서 분리된 상태 `em.detach(entity);`
4. 삭제 : 객체를 삭제한 상태 `em.remove(entity);`

## 영속성 컨텍스트의 이점

1. 1차 캐시
2. 동일성 보장
3. 변경 감지(Dirty Checking)
4. 트랜젝션을 지원하는 쓰기 지연
5. 지연 로딩

### 1차 캐시

엔티티가 영속화되었을 때, 1차 캐시에 적재된다. 
만약 데이터베이스에서 특정 엔티티의 정보를 찾고자했을 때, 먼저 이 1차 캐시에서 정보를 찾는다.
만약 없을시 DB를 조회하고, 이 찾은 정보를 1차 캐시에 적재한다.
트랜젝션이 끝나면 소멸한다.

### 동일성 보장

엔티티는 영속성 컨텍스트에서 고유 식별자를 통해 식별되며, 한 번 조회된 엔티티는 같은 트랜젝션 내에서 같은 엔티티로 관리된다.

### 트랜젝션을 지원하는 쓰기 지연

트랜젝션이 커밋되기까지 DB에 바로 반영하지 않는다. '쓰기 지연 저장소'에 쌓아놨다가 `flush();`가 되는 시점에 DB에 반영된다.

### 변경 감지(Dirty Checking)

영속성 컨텍스트는 상태를 저장해놓는 '스냅샷'이 있다. commit 혹은 flush 시점에 엔티티 상태와 스냅샷을 비교해서 변경된 엔티티가 있으면 쓰기 지연 저장소에 update 쿼리를 추가한다.

#### 영속성 컨텍스트를 flush()하는 방법

1. 직접 호출
2. 커밋 -> flush() 자동호출됨
3. JPQL -> flush() 자동호출됨

flush()는 **영속성 컨텍스트를 비우는 개념이 아니**라, 변경 내용을 DB에 반영하는 것이다. 











### Q&A 




1. ORM 

* JPA 와 같은 ORM을 사용하는 이유는 ?
 
답변 : SQL 중심적인 개발에서 객체 중심으로 개발하기 위함이다. 패러다임의 불일치를 해결하고 반복적인 CRUD SQL 을 해결해준다.
장점은 객체지향적인 코드를 작성할 수 있고 DB 를 변경해야 하는 경우 새로 쿼리를 짜지 않아도 된다. 

단점은 잘못 설계할 경우 속도의 저하가 생기며 복잡한 쿼리의 경우 별도의 튜닝이 필요하기 때문에 sql 을 써야할 수도 있다. 
* 영속성은 어떠한 기능을 하냐 ? 이게 진짜 성능 향상에 큰 도움이 되냐 ?

영속성은 flush 메서드를 직접 호출해야 영속성 컨텍스트의 내용이 데이터 베이스에 반영이 된다. 

* @Transactional 은 어떠한 기능을 하나 ?
지연 로딩을 하면 연결된 다른 엔티티의 값을 가져올 수 없다. 이러한 문제를 해결하기 위해서는 데이터베이스의 재연결이 필요하다. 

해당 어노테이션은 해당 메서드를 하나의 트랜잭션으로 처리하라는 의미이다. 기본적으로 필요할 때에 다시 데이터베이스와의 연결이 생성된다. 

---------


2. 영속성 컨텍스트 

* 영속성 컨텍스트의 내용을 데이터 베이스에 반영하려면 어떻게 해야하나요 ?

답 : 트랜잭션을 커밋해야 합니다 


* JPQL 쿼리를 실행할 때 왜 플러시 되나요 ?

답 : 엔티티를 영속 상태로 만들고 JPQL을 실행할 때에 데이터베이스에 반영이 안된다면 영속화된 엔티티는 JPQL 을 통해 조회되지 않는다. 
따라서 쿼리의 실행 전 데이터베이스에 반영한 뒤 JPQL 을 실행해야 한다. 

* Flush 와 Commit 의 차이는 ? 

답 : flush 는 쿼리를 전송하는 역할이고 commit 은 flush 를 수행하고 트랜잭션을 끝내는 역할이다.

----------------

3. Eager Lodaing / Lazy Loading 

* Eager Loading 에 대해 설명해 주세요 

답 : 엔티티 A 조회시 관련되어 있는 엔티티 B 를 같이 가져온다. 실제 엔티티를 맵핑한다. join을 사용하여 한번에 가져온다. 

* 그렇다면 Eager Loading 의 장/단점에 대해 설명해 주세요 

장점 : 지연된 초기화와 관련해서 성능적인 영향이 없다. 또한 연관된 엔티티를 모두 가져올 수 있다. 

단점 : 지연 로딩보다 긴 초기의 로딩 시간이 필요하다. 불필요한 데이터를 많이 로딩하면 성능에 영향을 줄 수 있다. 

* Lazy Loading 에 대해 설명해 주세요 

답 : 엔티티 A 를 조회 시 관련되어 있는 엔티티 B 를 한번에 가져오지 않는다. 프록시를 맵핑하고 실제 B 를 조회할 때에 쿼리가 나간다. 

* 그렇다면 Lazy Loading 의 장/단점에 대해 설명해 주세요 

장점 : 다른 접근 방식보다 훨씬 적은 초기의 로딩시간이다. 다른 접근 방식에 비해 메모리 소비량이 감소한다. 

단점 : 초기화가 지연되면 원하지 않은 순간 성능에 영향을 줄 수 있다. 

* Eager Loading / Lazy Loading 두 가지에 대해서 사용할 때에 주의해야 할 점은 무엇인가요 ?

가급적이면 지연 로딩을 사용해야 한다 

즉시 로딩은 예측이 어렵고 어떤 SQL 이 발생할지에 대한 예측이 어렵다. 

연관된 엔티티를 함께 DB 에서 조회해야 하면 fetch join 또는 엔티티 그래프 기능을 사용한다. 

@ to one 이면 기본적으로 즉시 로딩이기 때문에 직접 지연로딩으로 설정해야 한다. 


-----------------
4. N+1 
* FetchType.EAGER 와 FetchType.LAZY 의 차이점은 무엇인가요 

 EAGER 은 연관 엔티티를 즉시 로딩하는 것을 의미하며 LAZY 는 연관 엔티티를 필요한 시점에 지연 로딩하는 것을 의미합니다.

* N+1 발생 원인에 대해 설명해 주세요 
 
 한 번의 초기 쿼리 실행으로 가져온 데이터를 사용하는 도중 추가로 N 번의 쿼리를 실행해야 하기 때문이다. 


* 그렇다면 N+1 해결 방안에 대해 설명해 주세요 

 Fetch join 을 사용한다. 한 번의 쿼리로 연관 엔티티를 함께 로딩할 수 있기 때문이다. 추가적인 쿼리의 호출 없이 데이터를 한번에 가져올 수 있다. 
 
----------------

5. 다대다 해결 전략 

* M:N 의 문제점은 무엇인가요 ?

중간 테이블이 생성되지만 숨겨져 있기 때문에 출력을 할 때에 복잡한 조인으로 쿼리가 발생할 수 있다. 

중간 테이블에 필요한 컬럼이 저장되고 다른 정보는 저장되는 것이 불가능하다 


* 그렇다면 다대다일 경우의 해결 방법은 무엇인가요 ?

다대다 방식을 일대다 다대다로 풀어서 활용한다. 

------------

6. JPA 캐시 

* 1차 캐시와 2차 캐시에 대해 설명해 주세요 

 1차 캐시 : 영속성 컨텍스트 내부에 엔티티를 저장하여 빠른 데이터 조회와 업데이트를 지원하고 객체의 동일성을 보장한다. 트랜잭션 범위 내에서만 유호하다 

 2차 캐시 : 애플리케이션 범위의 캐시이다. 따라서 애플리케이션을 종료할 때까지 캐시가 유지된다. 객체의 동일성을 보장하지 않는다. 

* 왜 2차 캐시는 복사본을 반환할까요 ?

만약 캐시한 객체를 그대로 반환하면 멀티 스레드 환경에서 동시성 이슈가 발생할 수 있다. 
즉 캐시 한 객체를 여러 곳에서 수정하는 문제가 발생할 수 있다. 
